var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = JCheck","category":"page"},{"location":"reference/#Quickcheck","page":"Reference","title":"Quickcheck","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Quickcheck\nQuickcheck(::AbstractString)\n@add_predicate(::Any, ::Any, ::Any)\n@quickcheck(::Any, ::AbstractString)","category":"page"},{"location":"reference/#JCheck.Quickcheck","page":"Reference","title":"JCheck.Quickcheck","text":"Quickcheck\n\nContain a set of property to check through the generation of random input.\n\nFields\n\ndescription::AbstractString: description for the instance.\nrng::AbstractRNG: PRNG used to generate inputs.\npredicates::PredsAssoc: predicates to check.\nvariables::ArgsDict: Arguments used by the predicates.\nn::Int: Number of random inputs to generate.\nserialize_fails::Bool: If true, serialize failing inputs to a JLSO file.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JCheck.Quickcheck-Tuple{AbstractString}","page":"Reference","title":"JCheck.Quickcheck","text":"Quickcheck(desc; rng=GLOBAL_RNG, n=100, serialize_fails=true)\n\nConstructor for type Quickcheck.\n\nArguments\n\ndesc::AbstractString: description for the instance.\nrng::AbstractRNG: PRNG used to generate inputs.\nn::Int: Number of random inputs to generate.\nserialize_fails::Bool: If true, serialize failing inputs to a JLSO file.\n\nExamples\n\njulia> qc = Quickcheck(\"A Test\")\nA Test: 0 predicate and 0 free variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JCheck.@add_predicate-Tuple{Any, Any, Any}","page":"Reference","title":"JCheck.@add_predicate","text":"@add_predicate qc desc pred\n\nAdd the predicate pred to the set of tests qc with description desc.\n\nArguments\n\nqc: Object of type Quickcheck.\ndesc: String describing the predicate.\npred: Predicate in the form of an anonymous function.\n\nNotes\n\nThe form of pred is very strict:\n\nIt has to be an anonymous function. Formally, it should be an Expr of type ->.\nThe type of each argument appearing on the left-hand side of pred has to be specified with the x::Type syntax.\nThe names of the arguments of pred matter! Specifically, in a given Quickcheck object, the type of every argument must be consistent across predicates (see examples).\nEach predicate stored in a given Quickcheck object must be given a distinct description.\n\nExamples\n\njulia> qc = Quickcheck(\"A Test\")\nA Test: 0 predicate and 0 free variable.\n\njulia> @add_predicate qc \"Identity\" (x::Float64 -> x == x)\nA Test: 1 predicate and 1 free variable.\nx::Float64\n\njulia> @add_predicate qc \"Sum commute\" ((n::Int, x::Float64) -> n + x == x + n)\nA Test: 2 predicates and 2 free variables:\nn::Int64\nx::Float64\n\njulia> @add_predicate qc \"Is odd\" isodd(x)\nERROR: Predicate declaration must have the form of an anonymous function (... -> ...)\n[...]\n\njulia> @add_predicate qc \"Is odd\" (x::Int -> is_odd(x))\nERROR: A declaration for variable x already exists with type Float64; please choose another name for x\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JCheck.@quickcheck-Tuple{Any, AbstractString}","page":"Reference","title":"JCheck.@quickcheck","text":"@quickcheck qc [file_id::AbstractString=\"yyyy-mm-dd_HH-MM-SS\"]\n\nCheck the properties specified in object qc of type Quickcheck.\n\nIf qc.serialize_fails is true, serialize the failing cases to JCheck_<file_id>.jchk. Those can latter be analyzed using load and @getcases.\n\nNote\n\nIf no argument file_id is passed, defaults to current time.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Failed-Cases-Analysis","page":"Reference","title":"Failed Cases Analysis","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"FailedTests\nload(::Union{IO, AbstractString, AbstractPath})\n@getcases(::Any, ::Any...)","category":"page"},{"location":"reference/#JCheck.FailedTests","page":"Reference","title":"JCheck.FailedTests","text":"FailedTests\n\nContainer for failed tests from a @quickcheck run. Wrapper around a Dict{Symbol, Any} used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JCheck.load-Tuple{Union{AbstractString, IO, FilePathsBase.AbstractPath}}","page":"Reference","title":"JCheck.load","text":"load(io)\n\nLoad a collection of failed test cases serialized by a @quickcheck run.  Argument io can be of type IO, AbstractString or AbstractPath.\n\nExamples\n\njulia> ft = JCheck.load(\"JCheck_test.jchk\")\n2 failing predicates:\nProduct commute\nIs odd\n\n\n\n\n\n","category":"method"},{"location":"reference/#JCheck.@getcases-Tuple{Any, Vararg{Any}}","page":"Reference","title":"JCheck.@getcases","text":"@getcases ft, desc...\n\nGet the predicate with description desc and the valuations for which it failed.\n\nNote\n\nThe predicate with description closest to the one given (in the sense of the Levenshtein distance) will be returned; there is no need to pass the exact description.\n\nExamples\n\njulia> ft = JCheck.load(\"JCheck_test.jchk\")\n2 failing predicates:\nProduct commute\nIs odd\n\njulia> pred, valuations = @getcases ft iod\nNamedTuple{(:predicate, :valuations), Tuple{Function, Vector{Tuple}}}((Serialization.__deserialized_types__.var\"#3#4\"(), Tuple[(0,), (-9223372036854775808,), (6444904272543528628,)]))\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = JCheck","category":"page"},{"location":"#JCheck.jl-Documentation","page":"Home","title":"JCheck.jl Documentation","text":"","category":"section"},{"location":"#What-is-JCheck.jl?","page":"Home","title":"What is JCheck.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JCheck is a test framework for the Julia programming language. It aims imitating the one and only Quickcheck. The user specifies a set of properties in the form of predicates. JCheck then tries to falsifies these predicates. Since it is in general impossible to evaluate a predicate for every possible input, JCheck (as does QuickCheck) employs a Monte Carlo approach: it samples a set of inputs at random and pass them as arguments to the predicates. In order to make analysis of problematic cases more convenient, those can be serialized in a JLSO file for further experimentation.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Reuse inputs to cut into the time dedicated to cases generation.\nSerialization of problematic cases for convenient analysis.\nIntegration with Julia's testing framework.\nAllow specification of \"special cases\" i.e. non-random inputs that are always checked.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Container","page":"Home","title":"Container","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order for them to be used in a test, predicates must be contained in a Quickcheck object. Those are fairly easy to create. The most basic way is to call the constructor with a short and simple description:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Test:\n    @testset,\n    @test\n\nusing JCheck","category":"page"},{"location":"","page":"Home","title":"Home","text":"qc = Quickcheck(\"A Test\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more advanced usages, see documentation of the Quickcheck constructor.","category":"page"},{"location":"#Adding-predicates","page":"Home","title":"Adding predicates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once a Quickcheck object has been created, the next step is to populate it with predicates. This can be done with the @add_predicate macro:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@add_predicate qc \"Sum commute\" ((x::Float64, n::Int) -> x + n == n + x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A predicate is a function that returns either true or false. In the context of JCheck the form of the predicate is very strict; please read the documentation of @add_predicate.","category":"page"},{"location":"#(Quick)checking","page":"Home","title":"(Quick)checking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The macro @quickcheck launches the process of looking for falsifying instances in a Quickcheck object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@quickcheck qc\n\nTest Summary:    | Pass  Total\nTest Sum commute |    1      1","category":"page"},{"location":"#As-part-of-a-[@testset](https://docs.julialang.org/en/v1/stdlib/Test/#Test.@testset)","page":"Home","title":"As part of a @testset","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The @quickcheck macro can be nested inside @testset. This allows easy integration to a package's set of tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset \"Sample test set\" begin\n    @test isempty([])\n\n    @quickcheck qc\nend\n\nTest Summary:   | Pass  Total\nSample test set |    2      2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's add a failing predicate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@add_predicate qc \"I fail\" (x::Float64 -> false)\n\n@testset \"Sample failing test set\" begin\n    @test isempty([])\n\n    @quickcheck qc\nend\n\n┌ Warning: Predicate \"I fail\" does not hold for valuation (x = 0.0,)\n└ @ JCheck ~/Projets/JCheck/src/Quickcheck.jl:267\n┌ Warning: Predicate \"I fail\" does not hold for valuation (x = 1.0,)\n└ @ JCheck ~/Projets/JCheck/src/Quickcheck.jl:267\n\n[...]\n\nSome predicates do not hold for some valuations; they have been saved\nto JCheck_yyyy-mm-dd_HH-MM-SS.jchk. Use function load and macro @getcases\nto explore problematic cases.\n\nTest Summary:           | Pass  Fail  Total\nSample failing test set |    2     1      3\n  Test Sum commute      |    1            1\n  Test I fail           |          1      1\nERROR: Some tests did not pass: 2 passed, 1 failed, 0 errored, 0 broken.","category":"page"},{"location":"#Analysing-failing-cases","page":"Home","title":"Analysing failing cases","text":"","category":"section"},{"location":"#Testing-With-Custom-Types","page":"Home","title":"Testing With Custom Types","text":"","category":"section"}]
}
