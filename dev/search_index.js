var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = JCheck","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Quickcheck\nQuickcheck(::AbstractString)","category":"page"},{"location":"reference/#JCheck.Quickcheck","page":"Reference","title":"JCheck.Quickcheck","text":"Quickcheck\n\nContain a set of property to check through the generation of random input.\n\nFields\n\ndescription::AbstractString: description for the instance.\nrng::AbstractRNG: PRNG used to generate inputs.\npredicates::PredsAssoc: predicates to check.\nvariables::ArgsDict: Arguments used by the predicates.\nn::Int: Number of random inputs to generate.\nserialize_fails::Bool: If true, serialize failing inputs to a JLSO file.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JCheck.Quickcheck-Tuple{AbstractString}","page":"Reference","title":"JCheck.Quickcheck","text":"Quickcheck(desc; rng=GLOBAL_RNG, n=100, serialize_fails=true)\n\nConstructor for type Quickcheck.\n\nArguments\n\ndesc::AbstractString: description for the instance.\nrng::AbstractRNG: PRNG used to generate inputs.\nn::Int: Number of random inputs to generate.\nserialize_fails::Bool: If true, serialize failing inputs to a JLSO file.\n\nExamples\n\njulia> qc = Quickcheck(\"A Test\")\nA Test: 0 predicate and 0 free variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"@add_predicate(::Any, ::Any, ::Any)\n@quickcheck(::Any)","category":"page"},{"location":"reference/#JCheck.@add_predicate-Tuple{Any, Any, Any}","page":"Reference","title":"JCheck.@add_predicate","text":"@add_predicate qc desc pred\n\nAdd the predicate pred to the set of tests qc with description desc.\n\nArguments\n\nqc: Object of type Quickcheck.\ndesc: String describing the predicate.\npred: Predicate in the form of an anonymous function.\n\nNotes\n\nThe form of pred is very strict:\n\nIt has to be an anonymous function. Formally, it should be an Expr of type ->.\nThe type of each argument appearing on the left-hand side of pred has to be specified with the x::Type syntax.\nThe names of the arguments of pred matter! Specifically, in a given Quickcheck object, the type of every argument must be consistent across predicates (see examples).\nEach predicate stored in a given Quickcheck object must be given a distinct description.\n\nExamples\n\njulia> qc = Quickcheck(\"A Test\")\nA Test: 0 predicate and 0 free variable.\n\njulia> @add_predicate qc \"Identity\" (x::Float64 -> x == x)\nA Test: 1 predicate and 1 free variable.\nx::Float64\n\njulia> @add_predicate qc \"Sum commute\" ((n::Int, x::Float64) -> n + x == x + n)\nA Test: 2 predicates and 2 free variables:\nn::Int64\nx::Float64\n\njulia> @add_predicate qc \"Is odd\" isodd(x)\nERROR: Predicate declaration must have the form of an anonymous function (... -> ...)\n[...]\n\njulia> @add_predicate qc \"Is odd\" (x::Int -> is_odd(x))\nERROR: A declaration for variable x already exists with type Float64; please choose another name for x\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JCheck.@quickcheck-Tuple{Any}","page":"Reference","title":"JCheck.@quickcheck","text":"@quickcheck qc\n\nCheck the properties specified in object qc of type Quickcheck.\n\nIf qc.serialize_fails is true, serialize the failing cases to JCheck_yyyy-mm-dd_HH-MM-SS.jchk. Those can latter be analyzed using load and @getcases.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = JCheck","category":"page"},{"location":"#JCheck.jl-Documentation","page":"Home","title":"JCheck.jl Documentation","text":"","category":"section"},{"location":"#What-is-JCheck.jl?","page":"Home","title":"What is JCheck.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JCheck is a test framework for the Julia programming language. It aims imitating the one and only Quickcheck. The user specifies a set of properties in the form of predicates. JCheck then tries to falsifies these predicates. Since it is in general impossible to evaluate a predicate for every possible input, JCheck (as does QuickCheck) employs a Monte Carlo approach: it samples a set of inputs at random and pass them as arguments to the predicates. In order to make analysis of problematic cases more convenient, those can be serialized in a JLSO file for further experimentation.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Reuse inputs to cut into the time dedicated to cases generation.\nSerialization of problematic cases for convenient analysis.\nIntegration with Julia's testing framework.\nAllow specification of \"special cases\" i.e. non-random inputs that are always checked.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Container","page":"Home","title":"Container","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order for them to be used in a test, predicates must be contained in a Quickcheck object. Those are fairly easy to create. The most basic way is to call the constructor with a short and simple description:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Test:\n    @testset,\n    @test\n\nusing JCheck","category":"page"},{"location":"","page":"Home","title":"Home","text":"qc = Quickcheck(\"A Test\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more advanced usages, see documentation of the Quickcheck constructor.","category":"page"},{"location":"#Adding-predicates","page":"Home","title":"Adding predicates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once a Quickcheck object has been created, the next step is to populate it with predicates. This can be done with the @add_predicate macro:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@add_predicate qc \"Sum commute\" ((x::Float64, n::Int) -> x + n == n + x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A predicate is a function that returns either true or false. In the context of JCheck the form of the predicate is very strict; please read the documentation of @add_predicate.","category":"page"},{"location":"#(Quick)checking","page":"Home","title":"(Quick)checking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The macro @quickcheck launch the process of looking for falsifying instances in a Quickcheck object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@quickcheck qc","category":"page"},{"location":"#As-part-of-a-[@testset](https://docs.julialang.org/en/v1/stdlib/Test/#Test.@testset)","page":"Home","title":"As part of a @testset","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The @quickcheck macro can be nested inside @testset. This allows easy integration to a package's set of tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset \"Sample test set\" begin\n    @test isempty([])\n\n    @quickcheck qc\nend\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's add a failing predicate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@add_predicate qc \"I fail\" (x::Float64 -> false)\n\n@testset \"Sample failing test set\" begin\n    @test isempty([])\n\n    @quickcheck qc\nend\n\n┌ Warning: Predicate \"I fail\" does not hold for valuation (x = 0.0,)\n└ @ JCheck ~/Projets/JCheck/src/Quickcheck.jl:267\n┌ Warning: Predicate \"I fail\" does not hold for valuation (x = 1.0,)\n└ @ JCheck ~/Projets/JCheck/src/Quickcheck.jl:267\n\n[...]\n\nSome predicates do not hold for some valuations; they have been saved\nto JCheck_yyyy-mm-dd_HH-MM-SS.jchk. Use function load and macro @getcases\nto explore problematic cases.\n\nTest Summary:           | Pass  Fail  Total\nSample failing test set |    2     1      3\n  Test Sum commute      |    1            1\n  Test I fail           |          1      1\nERROR: Some tests did not pass: 2 passed, 1 failed, 0 errored, 0 broken.","category":"page"},{"location":"#Analysing-failing-cases","page":"Home","title":"Analysing failing cases","text":"","category":"section"},{"location":"#Testing-With-Custom-Types","page":"Home","title":"Testing With Custom Types","text":"","category":"section"}]
}
